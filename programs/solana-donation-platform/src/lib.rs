use anchor_lang::prelude::*;
use anchor_lang::solana_program::rent;
use anchor_lang::solana_program::program::invoke;
use anchor_lang::solana_program::system_instruction;

/*=====================================================================================*/
/***
 * Remember that in the beginning of our code, there’s that line declare_id!("");
 * Now as we are getting closer to production, we need to replace it with the unique 
 * Program ID generated by anchor build. We can get it with this command:
 * 
 * [solana address -k target/deploy/gm_solana-keypair.json]
 */
declare_id!("ESAXaQuTVApRKEVhgNPd3EnLgH7fNQhLRSu9pP5CJZ23");
/*=====================================================================================*/
#[program]
pub mod solana_donation_platform {

use super::*;
/*===============amount======================================================================*/
	pub fn initialize(ctx: Context<Initialize>, owner: Pubkey) -> Result<()> {
		let base_account = &mut ctx.accounts.base_account;
		base_account.owner = owner;
		Ok(())
	}
/*=====================================================================================*/
	pub fn donation(ctx: Context<Donation>, amount: u64) -> Result<()> {
		/*
		 * Make sure the amount of donated amount is bigger than zero
		 * if not, return the requred error.
		 */
		require!(amount > 0, DonationError::InvalidAmount);
		//=======================================================================
		// transfare the amount from the donator wallet account to the donation 
		//account,
		invoke(
			&system_instruction::transfer(
				&ctx.accounts.donator.key(),
				&ctx.accounts.donation.key(),
				amount,
			),
			&[
				ctx.accounts.donator.to_account_info(),
				ctx.accounts.donation.to_account_info(),
			],
		)
		.map_err(Into::<error::Error>::into)?;
		//=======================================================================
		let donation_data = &mut ctx.accounts.donation_data;
		donation_data.donator = ctx.accounts.donator.key();
		donation_data.donation = ctx.accounts.donation.key();
		donation_data.amount = donation_data.amount.saturating_add(amount);
		//=======================================================================
		emit!(DonationEvent
		{
			donation: ctx.accounts.donation.key(),
			donator: ctx.accounts.donator.key(),
			amount,
		});

		Ok(())
	}
/*=====================================================================================*/
	pub fn withdraw(ctx: Context<Withdraw>) -> Result<()> {

		let rent_exempt_amount = rent::Rent::get()?.minimum_balance(BaseAccount::LEN);
		let bank = ctx.accounts.donation.to_account_info();
		let dest = ctx.accounts.dest.to_account_info();

		let amount = bank.try_lamports()?.saturating_sub(rent_exempt_amount);
		
		require!(amount > 0, DonationError::Noamount);


		**dest.try_borrow_mut_lamports()? += amount;
		**bank.try_borrow_mut_lamports()? = amount;
		//=======================================================================
		emit!(WithdrawEvent {
			donation: ctx.accounts.donation.key(),
			dest: ctx.accounts.dest.key(),
			amount,
		});
		Ok(())
	}
/*=====================================================================================*/
}
/********************************
 * The most important thing here though is pub user: Signer<'info>. This is essentially
 * how we will be able to authenticate, to verify that this address is indeed the one 
 * that signed the transaction.
 * 
 * AccountInfo<'info> can also represent a user, but there’s no validation in place that
 *  anyone can be an imposter by simply passing in a random account.
 * 
 * pub system_program: Program<'info, System> ---->
 * refers to the root System Program, the special program on Solana that handles account creations.
 * If you leave it out, you won’t be able to initialize the base_account above.
 * 
 * 32 --> the size of the key,
 * 8 ----> 8-byte-discriminator.
 */

#[derive(Accounts)]
#[instruction(owner: Pubkey, bump: u8)]
pub struct Initialize<'info>
{
	#[account(init, payer = payer, space = 32 + 8, seeds = [owner.as_ref()], bump)]
	pub base_account: Account<'info, BaseAccount>,
	#[account(mut)]
	pub payer: Signer<'info>,
	pub system_program: Program<'info, System>,
}
/*=====================================================================================*/
/*
** AccountInfo<'info> can also represent a user, but there’s no validation in place that anyone can be an 
** imposter by simply passing in a random account.
**
** The macro #[account(mut)] means that the user here will be mutated, because it will be paying
** fees. This user field represents the signer of the transaction, 
** aka. the wallet that called this function.
*
*/
#[derive(Accounts)]
pub struct Donation<'info>
{
	#[account(mut)]
	pub donation: Account<'info, BaseAccount>,

	#[account(init_if_needed, payer = donator, space = 64 + 1024, seeds = [donator.key().as_ref()], bump)]
	pub donation_data: Account<'info, DonationData>,

	#[account(mut)]
	pub donator: Signer<'info>,
	pub system_program: Program<'info, System>,
}
//==================================================//BaseAccount
/*
 * This is the base account that will store the state of the program.
 */
#[account]
pub struct BaseAccount {
	pub owner: Pubkey,
}

impl BaseAccount {
    const LEN: usize = 32 + 8;
}
//==================================================//DonationData
#[account]
pub struct DonationData {
	donation: Pubkey,
	donator: Pubkey,
	amount: u64,

}
/*=====================================================================================*/
#[derive(Accounts)]
pub struct Withdraw<'info> {
#[account(mut)]
pub donation: Account<'info, BaseAccount>,
pub owner: Signer<'info>,
#[account(mut)]
pub dest: Account<'info, BaseAccount>,
#[account(mut)]
pub bank: Account<'info, DonationData>,
}
/*=====================================================================================*/
#[error_code]
pub enum DonationError {
	#[msg("amount of amount should be more than zero!!")]
	InvalidAmount,

	#[msg("The donation bank is empty")]
    Noamount,
}
/*=====================================================================================*/
#[event]
pub struct DonationEvent {
	pub donation: Pubkey,
	pub donator: Pubkey,
	pub amount: u64,
}

#[event]
pub struct WithdrawEvent {
    pub donation: Pubkey,
    pub dest: Pubkey,
    pub amount: u64,
}
/*=====================================================================================*/